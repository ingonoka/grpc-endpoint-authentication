/*
 * Copyright (c) 2023. Ingo Noka
 * This file belongs to project grpc-endpoint-authentication.
 * This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/3.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 */

package com.ingonoka.grpcendpointauthentication

import kotlinx.datetime.Clock
import kotlinx.datetime.Instant
import kotlin.time.Duration

const val EncryptionAlgorithm = "AES/CBC/PKCS5PADDING"

expect interface SecretKey

expect fun decrypt(key: SecretKey, encryptedSecret: ByteArray): Result<ByteArray>

expect fun encrypt(key: SecretKey, secret: ByteArray): Result<ByteArray>

expect fun generateKey(
    secretKeys: HashMap<EndpointIdentity, SecretKey>,
    endpointIdentity: EndpointIdentity,
    password: String = ""
): SecretKey


/**
 * Version 1 implementation of a token provider.
 *
 * The secret is generated by encrypting a string representation of the current time as epoch seconds with a key
 * that is derived from operator and terminal IDs.
 *
 * The secret is validated by decrypting the token secret and verify that it is a valid representation of a Long
 * number.
 * @return false if [checkTimeDifferenceMs] is not 0 and the time string represents a time that does not fall
 * in the time interval of +/- [checkTimeDifferenceMs] from now, return true otherwise
 */
class TokenProviderV1Impl(
    private val password: String = "",
    private val checkTimeDifferenceMs: Duration,
    private val timeProvider: () -> Instant
) : TokenProvider {

    /**
     * Cache secret keys because the key will be needed for every authentication
     */
    private var secretKeys: HashMap<EndpointIdentity, SecretKey> = hashMapOf()

    override fun validateToken(
        endpointIdentityAuthenticationToken: EndpointIdentityAuthenticationToken
    ): Result<Pair<ValidationResult, Instant?>> = try {

        require(endpointIdentityAuthenticationToken.version == 1)
        { "The version of the token for this token provider must be 1.  It is ${endpointIdentityAuthenticationToken.version}" }

        val key = generateKey(secretKeys, endpointIdentityAuthenticationToken.endpointIdentity, password)

        val tokenTime = decrypt(key, endpointIdentityAuthenticationToken.encryptedSecret)
            .map { Instant.fromEpochSeconds(it.toString(Charsets.UTF_8).toLong(10)) }
            .getOrThrow()

        val validationResult = if (checkTimeDifferenceMs != Duration.ZERO) {
            val now = Clock.System.now()
            if (tokenTime in (now - checkTimeDifferenceMs)..(now + checkTimeDifferenceMs)) {
                ValidationResult.VALID
            } else {
                ValidationResult.INVALID
            }
        } else {
            ValidationResult.VALID
        }

        Result.success(Pair(validationResult, tokenTime))

    } catch (e: Exception) {

        Result.failure(Exception("Token validation failed.", e))
    }

    override fun generateToken(endpointIdentity: EndpointIdentity): Result<EndpointIdentityAuthenticationToken> = try {

        val formattedTime: String = timeProvider().epochSeconds.toString(10)

        val key = generateKey(secretKeys, endpointIdentity, password)

        val encryptedSecret = encrypt(key, formattedTime.encodeToByteArray()).getOrThrow()

        val token = EndpointIdentityAuthenticationToken(1, endpointIdentity, encryptedSecret)

        Result.success(token)

    } catch (e: Exception) {

        Result.failure(Exception("Could not generate a token.", e))
    }
}